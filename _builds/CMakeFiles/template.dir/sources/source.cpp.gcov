        -:    0:Source:/home/rooted/Projects/C++/lab-01-parser/sources/source.cpp
        -:    0:Graph:/home/rooted/Projects/C++/lab-01-parser/_builds/CMakeFiles/template.dir/sources/source.cpp.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// Copyright 2018 Your Name <your_email>
        -:    2:
        -:    3:#include <header.hpp>
        -:    4:#include "Json.h"
        -:    5:
    #####:    6:Json::Json(const std::string& s) {
    #####:    7:    if (s[0] == '{'){
    #####:    8:        isArray = false;
    #####:    9:        auto regexPattern = R"~(\"\w+\":\[.*?\]|\"\w+\":\{.*?\}|\"\w+\":true|\"\w+\":false|\"\w+\":null|\"\w+\":\"\w+\"|\"\w+\":\d+)~";
        -:   10:        try {
    #####:   11:            auto regexObject = std::regex(regexPattern);
        -:   12:
    #####:   13:            auto copy = std::string(s);
        -:   14:
    #####:   15:            std::smatch mySmatch;
        -:   16:
    #####:   17:            if (std::regex_search(s, mySmatch, regexObject)) {
    #####:   18:                std::regex_token_iterator<std::string::iterator> rend;
        -:   19:                std::regex_token_iterator<std::string::iterator> a(
    #####:   20:                        copy.begin(), copy.end(), regexObject);
    #####:   21:                holder = std::map<std::string, std::any>();
    #####:   22:                while (a != rend) addToHolder(*a++);
        -:   23:            }
        -:   24:
    =====:   25:        } catch (const std::regex_error& e) {
    =====:   26:            std::cerr << "Error in regex \"" << regexPattern << "\"\nis: " << e.what()
    =====:   27:                      << std::endl;
        -:   28:        }
        -:   29:    }
        -:   30:    else {
    #####:   31:        isArray = true;
    #####:   32:        auto regexPattern = R"~(\"\w+\"|true|false|null|\d)~";
        -:   33:        try {
    #####:   34:            auto regexObject = std::regex(regexPattern);
        -:   35:
    #####:   36:            auto copy = std::string(s);
        -:   37:
    #####:   38:            std::smatch mySmatch;
        -:   39:
    #####:   40:            if (std::regex_search(s, mySmatch, regexObject)) {
    #####:   41:                std::regex_token_iterator<std::string::iterator> rend;
        -:   42:                std::regex_token_iterator<std::string::iterator> a(
    #####:   43:                        copy.begin(), copy.end(), regexObject);
    #####:   44:                holder = std::map<std::string, std::any>();
    #####:   45:                auto counter = 0;
    #####:   46:                while (a != rend) addArrayToHolder(*a++, counter++);
        -:   47:            }
        -:   48:
    =====:   49:        } catch (const std::regex_error& e) {
        -:   50:            std::cerr << "Error in regex \"" << regexPattern
    =====:   51:            << "\" \nis: " << e.what() << std::endl;
        -:   52:        }
        -:   53:    }
    #####:   54:}
        -:   55:
    #####:   56:void Json::addToHolder(const std::string& s) {
    #####:   57:    std::size_t offset = 0;
    #####:   58:    while (s[offset] == ' ') offset++;
    #####:   59:    auto substring = s.substr(offset);
    #####:   60:    auto key = substring.substr(0, s.find_first_of(':'));
    #####:   61:    offset = key.length() - 1;
    #####:   62:    while (key[key.length() - 1] == ' ') offset--;
    #####:   63:    key = key.substr(0, offset);
    #####:   64:    auto value = substring.substr(s.find_first_of(':'));
    #####:   65:    offset = 0;
    #####:   66:    while (s[offset] == ' ') offset++;
    #####:   67:    value = value.substr(offset);
    #####:   68:    offset = value.length() - 1;
    #####:   69:    while (value[offset] == ' ') offset--;
    #####:   70:    if (value[0] == '"') {
    #####:   71:        holder.insert(holderPair(key, value));
    #####:   72:    } else if (value == "true") {
    #####:   73:        holder.insert(holderPair(key, true));
    #####:   74:    } else if (value == "false") {
    #####:   75:        holder.insert(holderPair(key, false));
    #####:   76:    } else if (isdigit(value[0])) {
    #####:   77:        holder.insert(holderPair(key, std::stod(value)));
        -:   78:    } else {
    #####:   79:        holder.insert(holderPair(key, Json(value)));
        -:   80:    }
    #####:   81:}
        -:   82:
    #####:   83:void Json::addArrayToHolder(const std::string& value, const int& a) {
    #####:   84:    auto key = std::to_string(a);
    #####:   85:    if (value[0] == '"') {
    #####:   86:        holder.insert(holderPair(key, value));
    #####:   87:    } else if (value == "true") {
    #####:   88:        holder.insert(holderPair(key, true));
    #####:   89:    } else if (value == "false") {
    #####:   90:        holder.insert(holderPair(key, false));
    #####:   91:    } else if (isdigit(value[0])) {
    #####:   92:        holder.insert(holderPair(key, std::stod(value)));
        -:   93:    } else {
    #####:   94:        holder.insert(holderPair(key, Json(value)));
        -:   95:    }
    #####:   96:}
        -:   97:
    #####:   98:bool Json::is_array() const { return isArray; }
        -:   99:
    #####:  100:bool Json::is_object() const { return !isArray; }
        -:  101:
    #####:  102:std::any& Json::operator[](const std::string& key) {
    #####:  103:    if (!isArray) {
    #####:  104:        return holder[key];
        -:  105:    } else {
    #####:  106:        throw std::logic_error(R"~(Arrays cannot be accessed by keys, only indeces! Use Json::operator[](int index) instead.)~");
        -:  107:    }
        -:  108:}
        -:  109:
    #####:  110:std::any& Json::operator[](int index) {
    #####:  111:    if (isArray) {
    #####:  112:        return holder[std::to_string(index)];
        -:  113:    } else {
    #####:  114:        throw std::logic_error(R"~(Objects cannot be accessed by indeces, only keys! Use Json::operator[](const std::string& key) instead.)~");
        -:  115:    }
        -:  116:}
        -:  117:
    #####:  118:Json Json::parse(const std::string& s) { return Json(s); }
        -:  119:
    #####:  120:Json Json::parseFile(const std::string& path_to_file) {
    #####:  121:    std::experimental::filesystem::path path(path_to_file);
    #####:  122:    std::ifstream f(path);
    #####:  123:    const auto size = std::experimental::filesystem::file_size(path);
    #####:  124:    std::string data(size, ' ');
    #####:  125:    f.read(data.data(), size);
    #####:  126:    return Json(data);
    #####:  127:}
